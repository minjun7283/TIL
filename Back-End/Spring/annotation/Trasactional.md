# Transactional

우리가 평상시 서비스 계층의 메서드에 달아놓는 @Transectional에 대해 설명하기 전에 먼저 트랜잭션에 대해 설명해야 한다.

## 트랜잭션이란?

- 데이터베이스의 상태를 변경하는 작업 또는 한번에 수행되어야 하는 연산들을 의미한다.
- begin, commit 을 자동으로 수행해준다.
-예외 발생 시 자동으로 rollback을 실행해준다.

## 트랜잭션의 4속성

- 원자성(Atomicity)
    - 한 트랜잭션 내에서 실행한 작업들은 하나의 단위로 처리한다.(ex : 모두)

- 일관성(Consistency)
    - 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.

- 격리성(Isolation)
    - 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리시켜야 한다.

- 영속성(Durability)
    - 트랜잭션이 성공적으로 마치면 결과가 항상 저장되어야 한다.

## @Transectional

메소드, 클래스 ,인터페이스 위에 추가하여 설정하는 방식이 일반적이다.이 방식을 선언적 트랜잭션이라 부르며 적용된 범위 내에서는 트랜잭션 기능이 호함된 프록시 객체가 자동으로 commit, rollback 등을 처리해 준다.

## @Transectional

@Transectional이 붙은 메서드를 호출할 경우, 해당 메서드에 대한 프록시가 생성된다.프록시 패턴은 디자인 패턴 중 하나로, 어떤 코드를 감싸면서 부가적인 연산을 강제로 수행가게 만드는 방식이다.

트랜잭션은 시작과 끝에 커밋이 필요하므로, 프록시를 생성하여 해당 메서드의 앞뒤의 트랜잭션의 시작과 끝에 추가하는 것이다.이러한 로직은 AOP를 바탕으로 설계되어, 트랜잭션AOP라고 불린다.

또한 서비스 클래스에서 @Transectional 사용할 경우, 해당 코드 내의 메서드를 호출할 경우 영속성 컨테이너가 생긴다. 영속성 컨테이너는 트랜잭션AOP가 트랜잭션을 시작할떄 생겨나고, 메서드가 종료되면 트랜잭션AOP가 트랜잭션을 커밋할 경우 영속성 컨테이너가 flush하여 DB에 내용이 반영이 된다. 그 후  영속성 컨테이너도 종료된다.

이러한 방식으로 영속성 컨테이너를 관리해 주기 떄문에 @Transectional을 사용할 떄 트랜잭션의 원칙을 지킬 수 있다.

- 만약 같은 트랜잭션에서 여러 EntityManager를 상요하더라도, 동일한 영속성 컨테이너를 사용하게 된다.
- 같은 EnittyManager를 사용하더라도, 트랜잭션이 다르면 다른 영속성 컨테이너를 사용하게 된다.

## 트랜잭션의 옵셥

1. Isolation : 트랜잭션에 일관성없는 데이터 허용 수준을 설정한다.
2. propagation : 트랜잭션 도중 다른 트랜잭션을 호출할 경우 어떻게 할 것인지 지정하는 옵션이다.
3. noRollbackFor : 특정 예외 발생 시 Rollback하지 않는다.
4. rollbackFor : 특정 예외 발생 시 rollback 한다.
5. timeout : 지정한 시간내에 처리하지 못하면 rollback한다.(-1설정하면 timeout을 사용하지 않는다.) 
6. readOnly : 트랜잭션을 읽기 전용으로 설정한다.


